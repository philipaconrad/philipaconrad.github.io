---
title: "Useful Golang Tricks I've Learned"
date: 2024-10-19
summary: "A collection of useful tools, libraries, and techniques I've learned in the Golang ecosystem."
---

I started programming in Go in May of 2022, after leaving graduate school.
The startup I joined was a Golang shop, and while I was skeptical of Go at first (I thought Rust was far superior at the time!), I wound up being pleasantly surprised by the maturity of the tooling, and the general "get stuff done" mindset of the community.
I've come to enjoy working in Go, and have found that while it's often ugly language, it is unreasonably effective for a lot of programming tasks.

This article is my attempt to distill out some of the useful and weird stuff I've learned about Go from my work notes.

----

# `GOSSAFUNC` and `go build`

 - Dave Cheny's [blog post on GOSSAFUNC](https://dave.cheney.net/tag/gossafunc)
 - Go compiler [docs Intro to the SSA subsystem](https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/README.md)

When you're doing very low-level optimization work in Go, sometimes it's useful to see the SSA generated by the compiler.
The Go compiler provides an environment variable to allow you to select out function(s) that match a given name pattern.
It will then dump the SSA for everything that matches that pattern into a detailed, interactive HTML report.

Here's an example from the Open Policy Agent project:

    env "GOSSAFUNC=ast.(*object).Compare" go build

Which if you run the above command on the OPA repo, it will print out:

    # github.com/open-policy-agent/opa/ast
    dumped SSA for (*object).Compare,1 to ./ssa.html

The report is in `ssa.html`, and shows the SSA for the function as it moves through the different compiler optimization stages.
Very cool when you need it!


# Replacing dependencies in `go.mod`

 - Official Go docs:
   - Go Modules Reference, [`replace` directive section](https://go.dev/ref/mod#go-mod-file-replace)
   - `go.mod` File format Reference, [`replace` directive](https://go.dev/doc/modules/gomod-ref#replace)

Go projects are built around a top-level `go.mod` (and `go.sum`) file that tracks the master list of all the package dependencies needed to build the project.
Sometimes, you want to *replace* one of those packages with something else, maybe a homegrown alternative library, or a personal fork of some abandoned open source project.

In those cases, the `replace` directive is your friend.

// TODO: EXAMPLE




# See what's happening in your program with `runtime/trace` + `gotraceui`

 - Go Stdlib [`runtime/trace` package docs](https://pkg.go.dev/runtime/trace)
 - `gotraceui` links:
   - [Project website](https://gotraceui.dev/) (with screenshots!)
   - [Github repo](https://github.com/dominikh/gotraceui)

Tracing is a stupidly powerful technique, but staring at traces to build up an intuition about the program's behavior is time-consuming.
In Go, some hardy souls have already gone and built both detailed tracing and visualization tooling!

You can install `gotraceui` with the incantation: `go install honnef.co/go/gotraceui/cmd/gotraceui@master` (direct ref to `master` required to pick up unreleased Go 1.22+ patches.)

Here's the general steps I follow to get beautiful trace visualizations:

 - Copy/paste the tracing-specific code from the [`runtime/trace` package example code](https://pkg.go.dev/runtime/trace#example-package) to my `main.go` file, above whatever logic was already there.
 - Build and run the program with whatever inputs I care about.
   - The program will run slower than normal, and may chug a bit due to disk IO for the trace.
   - The trace will be written to a file named: `trace.out`
 - If it's a server program: `pkill <my_server_program>` (to ensure the shutdown process allows for flushing the full trace to disk)
 - `gotraceui trace.out`
   - This will render the entirety of the trace in an interactive, zoomable UI!

I use `gotraceui` to optimize allocation behavior, goroutine spawning patterns, GC overheads, and more.
It's also amazing for quickly gaining an understanding of complex concurrency situations.


# Build tags

 - Go docs: [`go/build`](https://pkg.go.dev/go/build)


One feature I desperately missed from C++ was conditional compilation with `#ifdef`.
I know, it seems a strange thing to miss-- the preprocessor is one of the most hideous parts of the C/C++ language family-- but it offers a terribly useful capability.
The ability to deal with multiple *world-scale* hazards, like different chip architectures and operating systems, is incredible.

Turns out, Go supports this very thing!
Go has a system for "build constraints", also called "build tags", which solves the problem at a coarse (file-level) granularity.
As with many Go things, it's ugly, but effective.

Here's an example of build variants:

// TODO DEBUG EXAMPLE


At work, we've used build tags so that we can painlessly switch implementations of some big features, without the programmer having to do anything different except adding a tag at build or test time for a project.



# How to use `go test` correctly

`go test` does exactly what it says on the tin-- it runs your tests.
But it also packs a *lot* of other features, and has a few surprising behaviors that can bite you in the keister at the worst times.

## Gotcha: Test caching

Go caches the results of `go test` by default, allowing very fast incremental test runs.
However! This is often not what you want, and sometimes you just want *all* of the tests to run.

In these cases the `-count=1` option is what you want.

Example: `go test ./... -count=1`

## Run all tests, recursively

    go test ./... -count=1

## Run tests for one package, recursively

    go test ./pkg/plugins/mystery_pkg/... -count=1

## Run all tests with a particular name prefix, suffix, or basic regex

    go test ./topdown -run "TestRego$/parse_units" -count=1

The above example comes straight from my work notes, back when I was debugging something related to the Open Policy Agent's [`units.parse` built-in function](https://www.openpolicyagent.org/docs/latest/policy-reference/#builtin-units-unitsparse).

Here's another example, matching on name prefix:

    go test -run ^TestTLS ./... -count=1

This one would match any test name in the whole project, starting with `TestTLS`.
So, test names like `TestTLSBrokenConnection` and `TestTLSBadHandshake` would be picked up and run, but names like `TestMutualTLS` would not, because the prefix does not match.

// TODO: Add the (a|b|c) syntax

# Make your tests run faster with `t.Parallel()`

 - Official Go reference docs for [`testing.(*T).Parallel`](https://pkg.go.dev/testing#T.Parallel)
 - Brandur's [article about using `t.Parallel()` in Go tests](https://brandur.org/t-parallel)
 - Robert Laszczak's [article on optimizing parallel Go tests](https://threedots.tech/post/go-test-parallelism/)

// TODO Write up the section on making tests go faster with t.Parallel.


# Helpful libraries!

## `sync.Pool` is incredible for reducing GC overhead

Ever wished you could just allocate a heavyweight object just once in Golang, and then be able to easily reuse that item *across goroutines*?
You could hack up something cool yourself, or ... you could use `sync.Pool` instead.

`sync.Pool` is based around the idea that you want a pool of "heavy" objects that can grow/shrink dynamically, but will allow reuse of the objects when possible.
The workflow:
 - Call `yourPool.Get()`
   - If an object is already allocated and ready in the pool, that's what your `Get()` call returns.
   - If nothing's allocated yet, the pool calls its `New()` method, allocating a new object from scratch.
 - Do whatever you need to do with the object.
 - Call `yourPool.Put(object)` to release the object back to the pool for other goroutines to use.

This basic workflow is unreasonably effective for objects that have complex initialization, or that take up a lot of memory.
As an example: in the Open Policy Agent project, we saw *substantial* capacity improvements (+9% requests per second), just from using a `sync.Pool` for caching our `gzip.Reader` decoder instances.


// TODO `sync.Pool` example code
// TODO find references for extended reading

